
BEGIN_MARKER = '---- BEGIN Pipeline definitions generated by Pipeline.py DO NOT EDIT'
END_MARKER = '---- END Pipeline definitions generated by Pipeline.py DO NOT EDIT'

class Pipeline(object):
    def __init__(self, width, fields, overlaps, constants):
        self.width = width
        self.fields = fields
        self.overlaps = overlaps
        self.constants = constants
        start = 0
        for name, w in fields.items():
            end = start + w
            if end > width:
                raise Exception(f'field {name} exceeds width of {width} bits by {end-width} bit(s)')
            start += w
        for name, (start, w) in self.overlaps.items():
            end = start + w
            if end > width:
                raise Exception(f'field {name} exceeds width of {width} bits by {end-width} bit(s)')

    def getDocs(self):
        lines = []
        lines.append('Microcode pipeline register')
        arr = []
        for i in range(0, self.width+8, 8):
            arr.append('%-8d' % i)
        lines.append(''.join(arr))
        arr = []
        for i in range(0, self.width, 8):
            arr.append('-------')
        markers = '|' + '|'.join(arr) + '|'
        start = 0
        n = 0
        for name, width in self.fields.items():
            spaces = ' '*start
            space_w = '_'*(width-2)
            end = start + width-1
            if n % 4 == 0:
                lines.append(markers)
            if width == 1:
                lines.append(f'{spaces}| - {name}[{start}]')
            else:
                lines.append(f'{spaces}|{space_w}| - {name}[{start}:{end}] {width} bits')
            start += width
            n += 1
        for name, (start, width) in self.overlaps.items():
            spaces = ' '*start
            space_w = '_'*(width-2)
            end = start + width-1
            if width == 1:
                lines.append(f'{spaces}| - {name}[{start}]')
            else:
                lines.append(f'{spaces}|{space_w}| - {name}[{start}:{end}] {width} bits')
        return lines

    def getVerilog(self):
        lines = []
        lines.append(f'reg [0:{self.width-1}] pipeline;')
        start = 0
        for name, width in self.fields.items():
            end = start + width-1
            if width == 1:
                lines.append(f'wire {name} = pipeline[{start}];')
            else:
                lines.append(f'wire [0:{width-1}] {name} = pipeline[{start}:{end}];')
            start += width
        for name, (start, width) in self.overlaps.items():
            end = start + width-1
            if width == 1:
                lines.append(f'wire {name} = pipeline[{start}];')
            else:
                lines.append(f'wire [0:{width-1}] {name} = pipeline[{start}:{end}];')
            start += width
        lines.append('')
        for name, value in self.constants.items():
            lines.append(f'localparam {name} = {value};')
        return lines

    def getMicroLines(self):
        lines = []
        lines.append('const seq.endian = BIG')
        lines.append(f'const seq.width = {self.width}')
        lines.append('')
        start = 0
        for name, width in self.fields.items():
            if name.startswith('seq_'):
                name = name.replace('seq_', 'seq.')
            end = start + width-1
            lines.append(f'field {name} = {start}:{end}')
            start += width
        for name, (start, width) in self.overlaps.items():
            end = start + width-1
            lines.append(f'field {name} = {start}:{end}')
        lines.append('')
        for name, value in self.constants.items():
            lines.append(f'const {name} = {value}')
        return lines

    def writeVerilog(self, filename):
        with open(filename) as f:
            sourcelines = f.readlines()
        with open(filename, "w") as f:
            for lineIndex in range(len(sourcelines)):
                if BEGIN_MARKER in sourcelines[lineIndex]:
                    break
                f.write(sourcelines[lineIndex])
            while lineIndex < len(sourcelines):
                if END_MARKER in sourcelines[lineIndex]:
                    break
                lineIndex += 1
            lineIndex += 1

            f.write(f'    // {BEGIN_MARKER}\n\n')
            for line in p.getDocs():
                f.write(f'    // {line}\n')
            f.write('\n')
            for line in self.getVerilog():
                f.write(f'    {line}\n')
            f.write(f'\n    // {END_MARKER}\n')
            while lineIndex < len(sourcelines):
                f.write(sourcelines[lineIndex])
                lineIndex += 1

    def writeMicro(self, filename):
        with open(filename) as f:
            sourcelines = f.readlines()
        with open(filename, "w") as f:
            for lineIndex in range(len(sourcelines)):
                if BEGIN_MARKER in sourcelines[lineIndex]:
                    break
                f.write(sourcelines[lineIndex])
            while lineIndex < len(sourcelines):
                if END_MARKER in sourcelines[lineIndex]:
                    break
                lineIndex += 1
            lineIndex += 1

            f.write(f'# {BEGIN_MARKER}\n\n')
            # for line in p.getDocs():
            #     f.write(f'# {line}\n')
            # f.write('\n')
            for line in self.getMicroLines():
                f.write(f'{line}\n')
            f.write(f'\n# {END_MARKER}\n')
            while lineIndex < len(sourcelines):
                f.write(sourcelines[lineIndex])
                lineIndex += 1

import sys

if __name__ == '__main__':
    fields = {}
    fields['seq_op'] = 2
    fields['seq_address_mux'] = 2
    fields['seq_condition'] = 4
    fields['ax'] = 3
    fields['bx'] = 2
    fields['cx'] = 3
    fields['csx'] = 2
    fields['dx'] = 3
    fields['ex'] = 3
    fields['lmx'] = 2
    fields['px'] = 3
    fields['qx'] = 2
    fields['rrx'] = 1
    fields['sx'] = 4
    fields['ende'] = 1
    fields['testa'] = 1
    fields['wd_en'] = 1
    fields['trap'] = 1
    fields['uc_debug'] = 1
    fields['write_size'] = 2
    fields['__unused'] = 1
    fields['seq_address'] = 12

    width = 0
    for k, v in fields.items():
        width += v

    print(f"Microword width: {width} bits")
    if width & 3 != 0:
        raise Exception("Microword width is not a multiple of 8 bits")

    if len(sys.argv) < 3:
        print('usage: python Pipeline.py <verilog-file> <micro-def-file>')
        sys.exit(1)

    overlaps = {}
    overlaps['_const12'] = (width-12, 12)

    constants = {}
    constants['AXNONE'] = 0
    constants['AXCONST'] = 1
    constants['AXE'] = 2
    constants['AXR'] = 3
    constants['AXRR'] = 4
    constants['AXS'] = 5
    constants['AXRR0'] = 6 # Contents of register 0, e.g. a <= rr[0]

    constants['BXNONE'] = 0
    constants['BXCONST'] = 1
    constants['BXS'] = 2

    constants['CXNONE'] = 0
    constants['CXCONST'] = 1
    constants['CXMB'] = 2
    constants['CXRR'] = 3
    constants['CXS'] = 4

    constants['CSXNONE'] = 0
    constants['CSXCONST'] = 1
    constants['CSXK00'] = 2

    constants['DXNONE'] = 0
    constants['DXCONST'] = 1
    constants['DXC'] = 2
    constants['DXCC'] = 3
    constants['DXNC'] = 4
    constants['DXPSW1'] = 5
    constants['DXPSW2'] = 6

    constants['EXNONE'] = 0
    constants['EXCONST'] = 1
    constants['EXB'] = 1
    constants['EXCC'] = 2
    constants['EXS'] = 3

    constants['LMXQ'] = 0
    constants['LMXP'] = 1
    constants['LMXC'] = 2

    constants['PXNONE'] = 0
    constants['PXCONST'] = 1
    constants['PXQ'] = 2
    constants['PXS'] = 3
    constants['PCTP1'] = 4  # P15-PP31 <= P15-PP31 + 1

    constants['QXNONE'] = 0
    constants['QXCONST'] = 1
    constants['QXP'] = 2

    constants['RRXNONE'] = 0
    constants['RRXS'] = 1

    constants['SXADD'] = 0      # S = A + D + CS
    constants['SXXOR'] = 1      # S = A ^ D
    constants['SXOR'] = 2       # S = A | D
    constants['SXAND'] = 3      # S = A & D
    constants['SXMA'] = 4       # S = -A
    constants['SXMD'] = 5       # S = -D
    constants['SXUAB'] = 6      # S = A upward align byte
    constants['SXUAH'] = 7      # S = A upward align halfword
    constants['SXUDB'] = 8      # S = D upward align byte
    constants['SXUDH'] = 9      # S = D upward align halfword
    constants['SXA'] = 10       # S = A
    constants['SXB'] = 11       # S = B
    constants['SXD'] = 12       # S = D
    constants['SXP'] = 13       # S15-S31 = P15-P31, S0-S1 = P32-P33

    constants['ADDR_MUX_SEQ'] = 0
    constants['ADDR_MUX_OPCODE'] = 1
    constants['ADDR_MUX_OPROM'] = 2

    constants['COND_NONE'] = 0
    constants['COND_CC_ZERO'] = 1
    constants['COND_CC_NEG'] = 2
    constants['COND_CC_POS'] = 3
    constants['COND_OP_INDIRECT'] = 4
    constants['COND_OP_INDEX'] = 5

    constants['WR_NONE'] = 0
    constants['WR_BYTE'] = 1
    constants['WR_HALF'] = 2
    constants['WR_WORD'] = 3

    p = Pipeline(width, fields, overlaps, constants)
    p.writeVerilog(sys.argv[1])
    p.writeMicro(sys.argv[2])
